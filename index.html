<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Demo Hệ Thống Tệp – Full Interactive</title>

<style>
body {
    font-family: Arial, sans-serif;
    background: #e9eef2;
    margin: 0;
    padding: 0;
}
.header {
    background: #2b4c7e;
    color: white;
    padding: 16px;
    font-size: 22px;
    text-align: center;
}
.container {
    width: 90%;
    margin: 20px auto;
    background: #fff;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 0 10px rgba(0,0,0,0.15);
}

/* Tabs */
.tab {
    display: flex;
    border-bottom: 2px solid #ccc;
    margin-bottom: 12px;
}
.tab button {
    padding: 10px 20px;
    border: none;
    cursor: pointer;
    background: #ddd;
    margin-right: 4px;
    border-radius: 6px 6px 0 0;
    font-weight: bold;
}
.tab button.active {
    background: #2b4c7e;
    color: white;
}

/* Content areas */
.content {
    display: none;
}

.row { display: flex; gap: 18px; }
.col { flex: 1; }

input[type="text"], input[type="number"], textarea {
    width: 100%;
    padding: 6px;
    margin-top: 4px;
    border-radius: 4px;
    border: 1px solid #ccc;
}
textarea { height: 120px; resize: vertical; }

button.action {
    background: #2b4c7e;
    color: white;
    border: none;
    padding: 7px 12px;
    margin: 4px 2px;
    border-radius: 4px;
    cursor: pointer;
}
button.action:hover { background: #213b62; }

#output, #fatOutput, #allocOutput {
    background: #111;
    color: #0f0;
    padding: 10px;
    height: 500px;
    border-radius: 6px;
    overflow-y: auto;
    font-family: Consolas;
    white-space: pre-wrap;
}

#fileList {
    background: #fafafa;
    height: 240px;
    padding: 6px;
    overflow-y: auto;
    border: 1px solid #ccc;
    border-radius: 6px;
}
#fileList div {
    padding: 4px;
    border-radius: 4px;
    cursor: pointer;
}
#fileList div:hover { background: #ddd; }
#fileList .active { background: #2b4c7e; color: white; }

/* FAT table */
#fatTable {
    border-collapse: collapse;
    width: 100%;
    margin-top: 10px;
}
#fatTable th, #fatTable td {
    border: 1px solid #aaa;
    padding: 6px;
    text-align: center;
}
#fatTable input {
    width: 60px;
}

/* Linked list diagram (tab 2) */
.list-diagram {
    margin-top: 15px;
    font-family: Consolas;
    white-space: pre;
    color: #003366;
    padding: 10px;
    border-left: 4px solid #2b4c7e;
    background: #eef4ff;
    border-radius: 6px;
}

/* Output cho Access Methods */
#accessOutput {
    background: #111;
    color: #0f0;
    padding: 10px;
    height: 280px;
    border-radius: 6px;
    overflow-y: auto;
    font-family: Consolas;
    white-space: pre-wrap;
}

/* Disk visualization for Allocation Methods */
#diskVisual {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.disk-block {
    width: 34px;
    height: 34px;
    border: 1px solid #999;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    background: #f5f5f5;
    position: relative;
    transition: transform 0.3s, background 0.3s, color 0.3s;
}

.disk-block.path {
    background: #ffe6a3;
}

.disk-block.active {
    background: #2b4c7e;
    color: #fff;
    transform: translateY(-4px);
}

/* ===== SƠ ĐỒ CONTIGUOUS & LINKED (dùng chung) ===== */
#contiguousDiagram,
#linkedDiagram {
    margin-top: 18px;
}

.linked-layout {
    display: flex;
    gap: 30px;
    align-items: flex-start;
    justify-content: flex-start;
}

.dir-box, .mem-box {
    background: #eaf4ff;
    border-radius: 10px;
    padding: 14px 16px;
    border: 1px solid #99b4e0;
}

.mem-box {
    position: relative;
}

.dir-title, .mem-title {
    font-weight: bold;
    text-align: center;
    margin-bottom: 8px;
}

.dir-table {
    border-collapse: collapse;
    width: 220px;
}
.dir-table th, .dir-table td {
    border: 1px solid #6c87b8;
    padding: 4px 6px;
    text-align: center;
    background: #f7fbff;
}

.mem-grid {
    display: grid;
    grid-template-columns: repeat(4, 70px);
    grid-auto-rows: 40px;
    gap: 6px 12px;
}

.mem-block {
    width: 70px;
    height: 40px;
    border-radius: 6px;
    border: 1px solid #6c87b8;
    background: #ffffff;
    font-size: 11px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: transform 0.3s, box-shadow 0.3s, background 0.3s, color 0.3s;
}
.mem-block .idx {
    font-weight: bold;
}
.mem-block .label {
    font-size: 10px;
    color: #2b4c7e;
}

.mem-block.file {
    background: #fff4cf;
}

.mem-block.file.active {
    background: #2b4c7e;
    color: #fff;
    transform: translateY(-4px);
    box-shadow: 0 0 6px rgba(0,0,0,0.4);
}
.mem-block.file.active .label {
    color: #fff;
}

/* SVG cho contiguous/linked arrows */
.link-arrows {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

/* ===== SƠ ĐỒ INDEXED ALLOCATION ===== */
#indexedDiagram {
    margin-top: 18px;
}

.indexed-layout {
    display: flex;
    gap: 30px;
    align-items: flex-start;
    justify-content: flex-start;
}

.index-box, .idata-box {
    background: #eaf4ff;
    border-radius: 10px;
    padding: 14px 16px;
    border: 1px solid #99b4e0;
}

.idata-box {
    position: relative;
}

.index-title, .idata-title {
    font-weight: bold;
    text-align: center;
    margin-bottom: 8px;
}

.index-table {
    border-collapse: collapse;
    width: 230px;
}
.index-table th, .index-table td {
    border: 1px solid #6c87b8;
    padding: 4px 6px;
    text-align: center;
    background: #f7fbff;
    font-size: 12px;
}

.index-cell {
    background: #fff4cf;
}
.index-cell.active {
    background: #2b4c7e;
    color: #fff;
}

.idata-grid {
    display: grid;
    grid-template-columns: repeat(4, 70px);
    grid-auto-rows: 40px;
    gap: 6px 12px;
}

.idata-block {
    width: 70px;
    height: 40px;
    border-radius: 6px;
    border: 1px solid #6c87b8;
    background: #ffffff;
    font-size: 11px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: transform 0.3s, box-shadow 0.3s, background 0.3s, color 0.3s;
}
.idata-block .idx {
    font-weight: bold;
}
.idata-block .label {
    font-size: 10px;
    color: #2b4c7e;
}

.idata-block.data {
    background: #fff4cf;
}
.idata-block.data.active {
    background: #2b4c7e;
    color: #fff;
    transform: translateY(-4px);
    box-shadow: 0 0 6px rgba(0,0,0,0.4);
}
.idata-block.data.active .label {
    color: #fff;
}

/* block là index block trên đĩa */
.idata-block.index {
    background: #cfd9ff;
    border-color: #2b4c7e;
}
.idata-block.index .label {
    color: #2b4c7e;
    font-weight: bold;
}

/* SVG cho indexed arrows */
.index-arrows {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

/* ======= TAB 4 – ACCESS METHODS ======= */
#accessDiagram {
    margin-top: 16px;
}

.access-layout {
    display: flex;
    gap: 30px;
    align-items: flex-start;
    justify-content: flex-start;
}

.file-box, .access-extra {
    background: #eaf4ff;
    border-radius: 10px;
    padding: 14px 16px;
    border: 1px solid #99b4e0;
}

.file-title, .access-extra-title {
    font-weight: bold;
    text-align: center;
    margin-bottom: 8px;
}

.records-row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.record-block {
    width: 70px;
    height: 50px;
    border-radius: 6px;
    border: 1px solid #6c87b8;
    background: #ffffff;
    font-size: 11px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: transform 0.3s, box-shadow 0.3s, background 0.3s, color 0.3s;
}
.record-block .idx {
    font-size: 10px;
    color: #555;
}
.record-block .val {
    font-weight: bold;
    color: #2b4c7e;
}

.record-block.active {
    background: #2b4c7e;
    color: #fff;
    transform: translateY(-4px);
    box-shadow: 0 0 6px rgba(0,0,0,0.4);
}
.record-block.active .idx,
.record-block.active .val {
    color: #fff;
}

/* bảng index / hash trong tab 4 */
.access-table {
    border-collapse: collapse;
    width: 230px;
}
.access-table th, .access-table td {
    border: 1px solid #6c87b8;
    padding: 4px 6px;
    text-align: center;
    background: #f7fbff;
    font-size: 12px;
}
.access-table tr.active {
    background: #2b4c7e;
    color: #fff;
}
</style>
</head>

<body>

<div class="header">DEMO HỆ THỐNG TỆP – FILE SYSTEM DEMO</div>

<div class="container">

    <!-- Tabs -->
    <div class="tab">
        <button class="active" onclick="openTab(event, 'tab1')">1. File-System Interface</button>
        <!-- <button onclick="openTab(event, 'tab2')">2. FAT – Linked List Blocks</button> -->
        <button onclick="openTab(event, 'tab3')">2. Allocation Methods</button>
        <!-- <button onclick="openTab(event, 'tab4')">3. Access Methods</button> -->
    </div>


    <!-- TAB 1 -->
    <div id="tab1" class="content" style="display:block;">
        <h2>1. Giao diện Hệ thống Tệp – Các thao tác tệp (File Operations)</h2>
        <p>
            Các thao tác tệp chính trong Chương 13:
            <b>Tạo, Mở, Ghi, Đọc, Định vị lại (Seek), Cắt ngắn, Xóa</b>.
        </p>

        <div class="row">
            <div class="col">

                <label>Tên tệp (file name)</label>
                <input type="text" id="filename" value="demo.txt">

                <label>Nội dung dùng để GHI tệp</label>
                <textarea id="writeContent"
                    placeholder="Nhập nội dung, sau đó dùng nút &quot;Ghi tệp&quot;..."></textarea>

                <label>Định vị lại trong tệp (Seek / Reposition)</label>
                <div class="row">
                    <div class="col">
                        <small>Vị trí bắt đầu (byte offset)</small>
                        <input type="number" id="seekPos" value="0">
                    </div>
                    <div class="col">
                        <small>Số ký tự cần đọc</small>
                        <input type="number" id="seekLen" value="20">
                    </div>
                </div>

                <div style="margin-top:15px;">
                    <button class="action" onclick="createFile()">Tạo một tệp</button>
                    <button class="action" onclick="openFile()">Mở một tệp</button>
                    <button class="action" onclick="writeFile()">Ghi một tệp</button>
                    <button class="action" onclick="readFile()">Đọc một tệp</button>
                    <button class="action" onclick="seekRead()">Định vị lại</button>
                    <button class="action" onclick="truncateFile()">Cắt ngắn một tệp</button>
                    <button class="action" onclick="deleteFile()">Xóa một tệp</button>
                    <button class="action" onclick="clearOutput()">Clear log</button>
                </div>
            </div>

            <div class="col">
                <label>Danh sách tệp (Directory giả lập)</label>
                <div id="fileList"></div>

                <label style="margin-top:10px;">Output mô phỏng thao tác</label>
                <div id="output"></div>
            </div>
        </div>
    </div>


    <!-- TAB 2 -->
    <div id="tab2" class="content">
        <h2>2. FAT – File Allocation Table (Linked List Simulation)</h2>

        <label>Số lượng block:</label>
        <input type="number" id="fatSize" value="10" min="1" style="width:120px;">
        <button class="action" onclick="generateFAT()">Tạo FAT</button>

        <div id="fatArea"></div>

        <h3>Linked List Chain</h3>
        <label>Block bắt đầu (Start block)</label>
        <input type="number" id="fatStart" value="0" style="width:120px;">
        <button class="action" onclick="showChain()">Hiển thị chain</button>

        <div id="fatOutput"></div>
        <div id="diagram" class="list-diagram"></div>
    </div>

    <!-- TAB 3 -->
    <div id="tab3" class="content">
        <h2>2. Allocation Methods – Mô phỏng các phương pháp cấp phát</h2>

        <p><b>Disk Size (số block trên đĩa):</b></p>
        <input type="number" id="diskSize" value="16" min="1" style="width:120px;">
        <button class="action" onclick="initDisk()">Khởi tạo đĩa</button>

        <h3>2.1 Contiguous Allocation (Cấp phát liên tục)</h3>
        <div class="row">
            <div class="col">
                <small>Start block</small>
                <input type="number" id="contigStart" value="2">
            </div>
            <div class="col">
                <small>Length (số block)</small>
                <input type="number" id="contigLen" value="5">
            </div>
        </div>
        <button class="action" onclick="demoContiguous()">Demo Contiguous</button>
        <div id="contiguousDiagram"></div>

        <h3>2.2 Linked Allocation (Danh sách liên kết – như FAT)</h3>
        <p><small>Nhập danh sách block cho file (vd: 0,5,10,13)</small></p>
        <input type="text" id="linkedBlocks" value="0,5,10,13">
        <button class="action" onclick="demoLinked()">Demo Linked</button>

        <div id="linkedDiagram"></div>

        <h3>2.3 Indexed Allocation (Cấp phát theo chỉ mục – i-node)</h3>
        <div class="row">
            <div class="col">
                <small>Index block (i-node)</small>
                <input type="number" id="indexBlock" value="3">
            </div>
            <div class="col">
                <small>Danh sách block dữ liệu (vd: 8,11,12,14)</small>
                <input type="text" id="indexDataBlocks" value="8,11,12,14">
            </div>
        </div>
        <button class="action" onclick="demoIndexed()">Demo Indexed</button>

        <div id="indexedDiagram"></div>

        <!-- <h3>Kết quả mô phỏng trên dải block</h3>
        <div id="diskVisual"></div>
        <div id="allocOutput"></div> -->
    </div>

    <!-- TAB 4 -->
    <div id="tab4" class="content">
        <h2>3. Access Methods – Các phương pháp truy cập tệp</h2>
        <p>
            File được mô phỏng là danh sách bản ghi phân cách bằng dấu phẩy, ví dụ:
            <code>R1,R2,R3,R4,R5</code>.<br>
            Bốn phương pháp truy cập: <b>Sequential, Direct, Indexed, Hashed</b>.
        </p>

        <label>Nội dung file (các bản ghi cách nhau bởi dấu phẩy)</label>
        <textarea id="accessFile">R1,R2,R3,R4,R5</textarea>

        <div class="row">
            <div class="col">
                <h3>3.1 Truy cập tuần tự (Sequential)</h3>
                <button class="action" onclick="demoSequential()">Demo Sequential</button>
            </div>
            <div class="col">
                <h3>3.2 Truy cập trực tiếp (Direct)</h3>
                <small>Vị trí bản ghi (0,1,2,...)</small>
                <input type="number" id="accessPos" value="2">
                <button class="action" onclick="demoDirect()">Demo Direct</button>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <h3>3.3 Indexed Access</h3>
                <small>Nhập khóa bản ghi (vd: R3)</small>
                <input type="text" id="accessKeyIndex" value="R3">
                <button class="action" onclick="demoIndexedAccess()">Demo Indexed Access</button>
            </div>
            <div class="col">
                <h3>3.4 Hashed Access</h3>
                <small>Nhập khóa (vd: user42)</small>
                <input type="text" id="accessKeyHash" value="user42">
                <button class="action" onclick="demoHashedAccess()">Demo Hashed Access</button>
            </div>
        </div>

        <h3>Mô phỏng trực quan</h3>
        <div id="accessDiagram"></div>

        <h3>Giải thích / Log</h3>
        <div id="accessOutput"></div>
    </div>

</div>

<script>
/* ---------------------- TAB switching ---------------------- */
function openTab(evt, tabName) {
    let i, content, tabs;
    content = document.getElementsByClassName("content");
    for (i = 0; i < content.length; i++) content[i].style.display = "none";

    tabs = document.querySelectorAll(".tab button");
    tabs.forEach(btn => btn.classList.remove("active"));

    document.getElementById(tabName).style.display = "block";
    evt.target.classList.add("active");
}

/* ---------------------- TAB 1: FILE SYSTEM ---------------------- */
let fileSystem = {};
let currentFile = null;

function log(msg) {
    let out = document.getElementById("output");
    out.innerHTML += msg + "\n";
    out.scrollTop = out.scrollHeight;
}

function refreshFileList() {
    let list = document.getElementById("fileList");
    list.innerHTML = "";
    let names = Object.keys(fileSystem);
    if (names.length === 0) {
        list.innerHTML = "<i>(Chưa có tệp)</i>";
        return;
    }
    names.forEach(name => {
        let div = document.createElement("div");
        div.textContent = name;
        if (currentFile && currentFile.name === name) div.classList.add("active");
        div.onclick = () => {
            currentFile = fileSystem[name];
            document.getElementById("filename").value = name;
            refreshFileList();
            log("Chọn tệp: " + name);
        };
        list.appendChild(div);
    });
}

function createFile() {
    let name = document.getElementById("filename").value.trim();
    if (!name) return alert("Nhập tên tệp trước!");

    if (fileSystem[name]) {
        log("Tệp '" + name + "' đã tồn tại → không tạo mới.");
    } else {
        fileSystem[name] = { name: name, content: "" };
        currentFile = fileSystem[name];
        log("Tạo một tệp mới: '" + name + "'.");
        refreshFileList();
    }
}

function openFile() {
    let name = document.getElementById("filename").value.trim();
    if (!name) return alert("Nhập tên tệp trước!");

    if (!fileSystem[name]) {
        alert("Tệp chưa tồn tại. Hãy tạo tệp trước.");
        return;
    }
    currentFile = fileSystem[name];
    log("Mở tệp: '" + name + "'.");
    refreshFileList();
}

function writeFile() {
    if (!currentFile) return alert("Hãy Mở tệp trước khi Ghi.");
    let text = document.getElementById("writeContent").value;
    currentFile.content = text;
    log(`Ghi một tệp: ghi ${text.length} ký tự vào '${currentFile.name}'.`);
}

function readFile() {
    if (!currentFile) return alert("Hãy Mở tệp trước khi Đọc.");
    log(`----- Đọc một tệp '${currentFile.name}' -----`);
    log(currentFile.content || "(Tệp đang trống)");
}

function seekRead() {
    if (!currentFile) return alert("Hãy Mở tệp trước khi Seek.");
    let pos = parseInt(document.getElementById("seekPos").value);
    let len = parseInt(document.getElementById("seekLen").value);
    if (isNaN(pos) || isNaN(len) || pos < 0 || len <= 0) {
        alert("Tham số seek không hợp lệ!");
        return;
    }
    let txt = currentFile.content.substring(pos, pos + len);
    log(`Định vị lại: từ byte ${pos}, đọc ${len} ký tự:`);
    log(txt || "(vượt ngoài phạm vi dữ liệu)");
}

function truncateFile() {
    if (!currentFile) return alert("Hãy Mở tệp trước khi Cắt ngắn.");
    currentFile.content = "";
    log("Cắt ngắn tệp '" + currentFile.name + "' về kích thước 0.");
}

function deleteFile() {
    if (!currentFile) return alert("Chưa có tệp nào đang được chọn để xóa.");
    let name = currentFile.name;
    delete fileSystem[name];
    currentFile = null;
    log("Xóa tệp: '" + name + "'.");
    refreshFileList();
}

function clearOutput() {
    document.getElementById("output").innerHTML = "";
}


/* ---------------------- TAB 2: FAT SIMULATION ---------------------- */
let FAT = [];

function generateFAT() {
    let size = parseInt(document.getElementById("fatSize").value);
    FAT = Array(size).fill(-1);

    let html = `<table id="fatTable"><tr><th>Block</th><th>Next</th></tr>`;
    for (let i = 0; i < size; i++) {
        html += `
            <tr>
                <td>${i}</td>
                <td><input type="number" id="fat_${i}" value="-1"></td>
            </tr>
        `;
    }
    html += "</table>";

    document.getElementById("fatArea").innerHTML = html;
}

function readFATInputs() {
    for (let i = 0; i < FAT.length; i++) {
        FAT[i] = parseInt(document.getElementById("fat_" + i).value);
    }
}

function showChain() {
    readFATInputs();

    let start = parseInt(document.getElementById("fatStart").value);
    if (isNaN(start) || start < 0 || start >= FAT.length)
        return alert("Block bắt đầu không hợp lệ!");

    let chain = [];
    let visited = new Set();
    let current = start;

    while (current !== -1 && !visited.has(current)) {
        chain.push(current);
        visited.add(current);
        current = FAT[current];
    }

    if (visited.has(current)) chain.push("(loop detected)");

    document.getElementById("fatOutput").innerText =
        "FAT Chain: " + chain.join(" → ") + " → NULL";

    let diag = "";
    chain.forEach((blk) => {
        if (blk === "(loop detected)") return;
        let next = FAT[blk];
        diag +=
`+---------+---------+
| Block   | ${blk.toString().padEnd(7)}|
+---------+---------+
| Next    | ${next === -1 ? "NULL" : next.toString().padEnd(7)}|
+---------+---------+
       |
       v
`;
    });

    diag += "END";

    document.getElementById("diagram").innerText = diag;
}

/* ---------------------- TAB 3: ALLOCATION METHODS ---------------------- */
let diskBlocks = [];
let allocAnimTimer = null;
let contigAnimTimer = null;
let linkedAnimTimer = null;
let indexedAnimTimer = null;

function initDisk() {
    const n = parseInt(document.getElementById("diskSize").value);
    if (isNaN(n) || n <= 0) return alert("Disk size không hợp lệ!");
    diskBlocks = new Array(n).fill('.');
    stopAllocAnimation();
    drawDisk([], -1, "Đã khởi tạo đĩa với " + n + " block.\nChưa có file nào được cấp phát.");
}

function drawDisk(path = [], current = -1, caption = "") {
    const visual = document.getElementById("diskVisual");
    if (!visual) return;
    let html = "";

    for (let i = 0; i < diskBlocks.length; i++) {
        let cls = "disk-block";
        if (path.includes(i)) cls += " path";
        if (i === current) cls += " active";
        html += `<div class="${cls}">${i}</div>`;
    }

    visual.innerHTML = html;
    document.getElementById("allocOutput").innerText = caption;
}

function stopAllocAnimation() {
    if (allocAnimTimer) { clearInterval(allocAnimTimer); allocAnimTimer = null; }
}

/* animation cho dải block */
function animatePath(path, baseCaption) {
    stopAllocAnimation();

    if (!Array.isArray(path) || path.length === 0) {
        drawDisk([], -1, baseCaption);
        return;
    }

    let step = -1;
    drawDisk(path, -1, baseCaption + "\n\nBắt đầu mô phỏng truy cập các block...");

    allocAnimTimer = setInterval(() => {
        step++;
        if (step >= path.length) {
            clearInterval(allocAnimTimer);
            allocAnimTimer = null;
            drawDisk(path, -1, baseCaption + "\n\nHoàn tất: các block thuộc file được đánh dấu màu vàng.");
            return;
        }

        const currentBlock = path[step];
        const caption = baseCaption +
            "\n\nĐang truy cập block: " + currentBlock +
            " (bước " + (step + 1) + " / " + path.length + ")";
        drawDisk(path, currentBlock, caption);
    }, 600);
}

/* ===== 3.1 CONTIGUOUS ALLOCATION – sơ đồ + mũi tên ===== */
function renderContiguousDiagram(totalBlocks, path) {
    const container = document.getElementById("contiguousDiagram");
    if (!container) return;

    if (!Array.isArray(path) || path.length === 0) {
        container.innerHTML = "<i>Chưa có file nào được cấp phát.</i>";
        return;
    }

    const start = path[0];
    const end   = path[path.length - 1];
    const length = path.length;

    let html = `
      <div class="linked-layout">
        <div class="dir-box">
          <div class="dir-title">Directory</div>
          <table class="dir-table">
            <tr><th>File</th><th>Start</th><th>Length</th></tr>
            <tr><td>File_1</td><td>${start}</td><td>${length}</td></tr>
          </table>
        </div>

        <div class="mem-box">
          <div class="mem-title">Memory (Contiguous Blocks)</div>
          <svg class="link-arrows" id="contigSvg"></svg>
          <div class="mem-grid">
    `;

    for (let i = 0; i < totalBlocks; i++) {
        const isFileBlock = path.includes(i);
        html += `
          <div class="mem-block ${isFileBlock ? "file" : ""}" id="contigBlock_${i}">
            <div class="idx">${i}</div>
            <div class="label">${isFileBlock ? "File_1" : "&nbsp;"}</div>
          </div>
        `;
    }

    html += `
          </div>
        </div>
      </div>
      <small><i>File_1 chiếm một đoạn liên tục trên đĩa, các block liền kề nhau; mũi tên minh họa hướng đọc.</i></small>
    `;

    container.innerHTML = html;
    setTimeout(() => drawContiguousArrows(path), 50);
}

function drawContiguousArrows(path) {
    const svg = document.getElementById("contigSvg");
    if (!svg) return;

    const memBox = svg.parentElement;
    const boxRect = memBox.getBoundingClientRect();

    svg.setAttribute("width", boxRect.width);
    svg.setAttribute("height", boxRect.height);
    svg.setAttribute("viewBox", `0 0 ${boxRect.width} ${boxRect.height}`);
    svg.innerHTML = "";

    const svgns = "http://www.w3.org/2000/svg";

    const defs = document.createElementNS(svgns, "defs");
    const marker = document.createElementNS(svgns, "marker");
    marker.setAttribute("id", "contigArrowHead");
    marker.setAttribute("markerWidth", "10");
    marker.setAttribute("markerHeight", "10");
    marker.setAttribute("refX", "8");
    marker.setAttribute("refY", "4");
    marker.setAttribute("orient", "auto");
    const mPath = document.createElementNS(svgns, "path");
    mPath.setAttribute("d", "M0,0 L8,4 L0,8 Z");
    mPath.setAttribute("fill", "#2b4c7e");
    marker.appendChild(mPath);
    defs.appendChild(marker);
    svg.appendChild(defs);

    const centers = [];
    path.forEach(b => {
        const el = document.getElementById("contigBlock_" + b);
        if (!el) return;
        const r = el.getBoundingClientRect();
        centers.push({
            x: r.left + r.width / 2 - boxRect.left,
            y: r.top + r.height / 2 - boxRect.top
        });
    });

    for (let i = 0; i < centers.length - 1; i++) {
        const c1 = centers[i];
        const c2 = centers[i + 1];
        const line = document.createElementNS(svgns, "line");
        line.setAttribute("x1", c1.x);
        line.setAttribute("y1", c1.y);
        line.setAttribute("x2", c2.x);
        line.setAttribute("y2", c2.y);
        line.setAttribute("stroke", "#2b4c7e");
        line.setAttribute("stroke-width", "2");
        line.setAttribute("marker-end", "url(#contigArrowHead)");
        svg.appendChild(line);
    }
}

function animateContiguousDiagram(path) {
    if (contigAnimTimer) {
        clearInterval(contigAnimTimer);
        contigAnimTimer = null;
    }
    if (!Array.isArray(path) || path.length === 0) return;

    let step = -1;

    contigAnimTimer = setInterval(() => {
        step++;

        path.forEach(b => {
            const el = document.getElementById("contigBlock_" + b);
            if (el) el.classList.remove("active");
        });

        if (step >= path.length) {
            clearInterval(contigAnimTimer);
            contigAnimTimer = null;
            return;
        }

        const blk = path[step];
        const el = document.getElementById("contigBlock_" + blk);
        if (el) el.classList.add("active");
    }, 700);
}

/* 3.1 Contiguous – logic chính */
function demoContiguous() {
    if (diskBlocks.length === 0) initDisk();
    const start = parseInt(document.getElementById("contigStart").value);
    const len   = parseInt(document.getElementById("contigLen").value);
    const n     = diskBlocks.length;

    if (isNaN(start) || isNaN(len) || start < 0 || len <= 0 || start + len > n) {
        alert("Thông số contiguous không hợp lệ!");
        return;
    }

    const used = [];
    for (let i = start; i < start + len; i++) used.push(i);

    let text = "== Contiguous Allocation ==\n";
    text += "Start = " + start + ", Length = " + len + "\n";
    text += "Các block được cấp phát liên tục cho File_1: " + used.join(", ") + "\n";
    text += "Đặc điểm: block nằm liền nhau → truy cập nhanh, khó mở rộng.\n";

    animatePath(used, text);
    renderContiguousDiagram(n, used);
    animateContiguousDiagram(used);
}

/* ======= 3.2 Linked Allocation ======= */
function renderLinkedDiagram(totalBlocks, path) {
    const container = document.getElementById("linkedDiagram");
    if (!container) return;

    if (!Array.isArray(path) || path.length === 0) {
        container.innerHTML = "<i>Chưa có chuỗi block nào.</i>";
        return;
    }

    const start = path[0];
    const end = path[path.length - 1];

    let html = `
      <div class="linked-layout">
        <div class="dir-box">
          <div class="dir-title">Directory</div>
          <table class="dir-table">
            <tr><th>File</th><th>Start</th><th>End</th></tr>
            <tr><td>File_1</td><td>${start}</td><td>${end}</td></tr>
          </table>
        </div>

        <div class="mem-box">
          <div class="mem-title">Memory (Linked Blocks)</div>
          <svg class="link-arrows" id="linkSvg"></svg>
          <div class="mem-grid">
    `;

    for (let i = 0; i < totalBlocks; i++) {
        const isFileBlock = path.includes(i);
        html += `
          <div class="mem-block ${isFileBlock ? "file" : ""}" id="memBlock_${i}">
            <div class="idx">${i}</div>
            <div class="label">${isFileBlock ? "File_1" : "&nbsp;"}</div>
          </div>
        `;
    }

    html += `
          </div>
        </div>
      </div>
      <small><i>Khối màu vàng là các block thuộc File_1; khối nhấp nháy thể hiện hướng duyệt theo con trỏ.</i></small>
    `;

    container.innerHTML = html;
    setTimeout(() => drawLinkedArrows(path), 50);
}

function drawLinkedArrows(path) {
    const svg = document.getElementById("linkSvg");
    if (!svg) return;

    const memBox = svg.parentElement;
    const boxRect = memBox.getBoundingClientRect();

    svg.setAttribute("width", boxRect.width);
    svg.setAttribute("height", boxRect.height);
    svg.setAttribute("viewBox", `0 0 ${boxRect.width} ${boxRect.height}`);
    svg.innerHTML = "";

    const svgns = "http://www.w3.org/2000/svg";

    const defs = document.createElementNS(svgns, "defs");
    const marker = document.createElementNS(svgns, "marker");
    marker.setAttribute("id", "arrowHead");
    marker.setAttribute("markerWidth", "10");
    marker.setAttribute("markerHeight", "10");
    marker.setAttribute("refX", "8");
    marker.setAttribute("refY", "4");
    marker.setAttribute("orient", "auto");
    const mPath = document.createElementNS(svgns, "path");
    mPath.setAttribute("d", "M0,0 L8,4 L0,8 Z");
    mPath.setAttribute("fill", "#2b4c7e");
    marker.appendChild(mPath);
    defs.appendChild(marker);
    svg.appendChild(defs);

    const centers = [];
    path.forEach(b => {
        const el = document.getElementById("memBlock_" + b);
        if (!el) return;
        const r = el.getBoundingClientRect();
        centers.push({
            x: r.left + r.width / 2 - boxRect.left,
            y: r.top + r.height / 2 - boxRect.top
        });
    });

    for (let i = 0; i < centers.length - 1; i++) {
        const c1 = centers[i];
        const c2 = centers[i + 1];
        const line = document.createElementNS(svgns, "line");
        line.setAttribute("x1", c1.x);
        line.setAttribute("y1", c1.y);
        line.setAttribute("x2", c2.x);
        line.setAttribute("y2", c2.y);
        line.setAttribute("stroke", "#2b4c7e");
        line.setAttribute("stroke-width", "2");
        line.setAttribute("marker-end", "url(#arrowHead)");
        svg.appendChild(line);
    }
}

function animateLinkedDiagram(path) {
    if (linkedAnimTimer) {
        clearInterval(linkedAnimTimer);
        linkedAnimTimer = null;
    }

    if (!Array.isArray(path) || path.length === 0) return;

    let step = -1;

    linkedAnimTimer = setInterval(() => {
        step++;

        path.forEach(b => {
            const el = document.getElementById("memBlock_" + b);
            if (el) el.classList.remove("active");
        });

        if (step >= path.length) {
            clearInterval(linkedAnimTimer);
            linkedAnimTimer = null;
            return;
        }

        const blk = path[step];
        const el = document.getElementById("memBlock_" + blk);
        if (el) el.classList.add("active");
    }, 700);
}

function demoLinked() {
    if (diskBlocks.length === 0) initDisk();
    const raw = document.getElementById("linkedBlocks").value.trim();
    if (!raw) return alert("Nhập danh sách block (vd: 0,5,10,13)");

    const parts = raw.split(",").map(x => parseInt(x.trim())).filter(x => !isNaN(x));
    if (parts.length === 0) return alert("Danh sách không hợp lệ!");

    const n = diskBlocks.length;
    for (let b of parts) {
        if (b < 0 || b >= n) {
            alert("Block " + b + " vượt kích thước đĩa!");
            return;
        }
    }

    const chain = parts.join(" → ") + " → NULL";

    let text = "== Linked Allocation (FAT-style) ==\n";
    text += "Chuỗi block của File_1:\n" + chain + "\n\n";
    text += "Mỗi block chứa con trỏ tới block tiếp theo.\n";

    animatePath(parts, text);
    renderLinkedDiagram(n, parts);
    animateLinkedDiagram(parts);
}

/* ======= 3.3 Indexed Allocation ======= */
function renderIndexedDiagram(totalBlocks, indexBlock, dataBlocks) {
    const container = document.getElementById("indexedDiagram");
    if (!container) return;

    let html = `
      <div class="indexed-layout">
        <div class="dir-box">
          <div class="dir-title">Directory</div>
          <table class="dir-table">
            <tr><th>File</th><th>Index block</th></tr>
            <tr><td>File_1</td><td>${indexBlock}</td></tr>
          </table>
        </div>

        <div class="index-box">
          <div class="index-title">Index Block (i-node)</div>
          <table class="index-table">
            <tr><th colspan="3">Block #${indexBlock}</th></tr>
            <tr><th>Entry</th><th>Pointer</th><th>Ghi chú</th></tr>
    `;

    dataBlocks.forEach((b, i) => {
        html += `
          <tr id="indexCell_${i}" class="index-cell">
            <td>${i}</td>
            <td>${b}</td>
            <td>→ block dữ liệu</td>
          </tr>
        `;
    });

    html += `
          </table>
        </div>

        <div class="idata-box">
          <div class="idata-title">Memory (Data Blocks)</div>
          <svg class="index-arrows" id="indexSvg"></svg>
          <div class="idata-grid">
    `;

    for (let i = 0; i < totalBlocks; i++) {
        const isData = dataBlocks.includes(i);
        const isIndex = (i === indexBlock);
        html += `
          <div class="idata-block ${isData ? "data" : ""} ${isIndex ? "index" : ""}" id="idataBlock_${i}">
            <div class="idx">${i}</div>
            <div class="label">
              ${isIndex ? "Index" : (isData ? "File_1" : "&nbsp;")}
            </div>
          </div>
        `;
    }

    html += `
          </div>
        </div>
      </div>
      <small><i>Directory trỏ đến index block; index block chứa con trỏ tới các block dữ liệu của File_1.</i></small>
    `;

    container.innerHTML = html;
    setTimeout(() => drawIndexedArrows(indexBlock, dataBlocks), 50);
}

function drawIndexedArrows(indexBlock, dataBlocks) {
    const svg = document.getElementById("indexSvg");
    if (!svg) return;

    const box = svg.parentElement;
    const boxRect = box.getBoundingClientRect();

    svg.setAttribute("width", boxRect.width);
    svg.setAttribute("height", boxRect.height);
    svg.setAttribute("viewBox", `0 0 ${boxRect.width} ${boxRect.height}`);
    svg.innerHTML = "";

    const svgns = "http://www.w3.org/2000/svg";

    const defs = document.createElementNS(svgns, "defs");
    const marker = document.createElementNS(svgns, "marker");
    marker.setAttribute("id", "arrowHead2");
    marker.setAttribute("markerWidth", "10");
    marker.setAttribute("markerHeight", "10");
    marker.setAttribute("refX", "8");
    marker.setAttribute("refY", "4");
    marker.setAttribute("orient", "auto");
    const mPath = document.createElementNS(svgns, "path");
    mPath.setAttribute("d", "M0,0 L8,4 L0,8 Z");
    mPath.setAttribute("fill", "#2b4c7e");
    marker.appendChild(mPath);
    defs.appendChild(marker);
    svg.appendChild(defs);

    const indexEl = document.getElementById("idataBlock_" + indexBlock);
    if (!indexEl) return;
    const rIndex = indexEl.getBoundingClientRect();
    const cx = rIndex.left + rIndex.width / 2 - boxRect.left;
    const cy = rIndex.top + rIndex.height / 2 - boxRect.top;

    dataBlocks.forEach(b => {
        const blockEl = document.getElementById("idataBlock_" + b);
        if (!blockEl) return;
        const r = blockEl.getBoundingClientRect();
        const x2 = r.left + r.width / 2 - boxRect.left;
        const y2 = r.top + r.height / 2 - boxRect.top;

        const line = document.createElementNS(svgns, "line");
        line.setAttribute("x1", cx);
        line.setAttribute("y1", cy);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("stroke", "#2b4c7e");
        line.setAttribute("stroke-width", "2");
        line.setAttribute("marker-end", "url(#arrowHead2)");
        svg.appendChild(line);
    });
}

function animateIndexedDiagram(indexBlock, dataBlocks) {
    if (indexedAnimTimer) {
        clearInterval(indexedAnimTimer);
        indexedAnimTimer = null;
    }
    if (!Array.isArray(dataBlocks) || dataBlocks.length === 0) return;

    let step = -1;

    indexedAnimTimer = setInterval(() => {
        step++;

        dataBlocks.forEach((b, i) => {
            const cell = document.getElementById("indexCell_" + i);
            const block = document.getElementById("idataBlock_" + b);
            if (cell) cell.classList.remove("active");
            if (block) block.classList.remove("active");
        });
        const indexBlockEl = document.getElementById("idataBlock_" + indexBlock);
        if (indexBlockEl) indexBlockEl.classList.remove("active");

        if (step === 0) {
            const indexBlockEl2 = document.getElementById("idataBlock_" + indexBlock);
            if (indexBlockEl2) indexBlockEl2.classList.add("active");
            return;
        }
        if (step > dataBlocks.length) {
            clearInterval(indexedAnimTimer);
            indexedAnimTimer = null;
            return;
        }

        const i = step - 1;
        const b = dataBlocks[i];
        const cell = document.getElementById("indexCell_" + i);
        const block = document.getElementById("idataBlock_" + b);
        if (cell) cell.classList.add("active");
        if (block) block.classList.add("active");
    }, 800);
}

function demoIndexed() {
    if (diskBlocks.length === 0) initDisk();

    const idx = parseInt(document.getElementById("indexBlock").value);
    const raw = document.getElementById("indexDataBlocks").value.trim();
    if (isNaN(idx)) return alert("Index block không hợp lệ!");

    const n = diskBlocks.length;
    if (idx < 0 || idx >= n) {
        alert("Index block vượt kích thước đĩa!");
        return;
    }

    const dataBlocks = raw
        ? raw.split(",").map(x => parseInt(x.trim())).filter(x => !isNaN(x))
        : [];

    for (let b of dataBlocks) {
        if (b < 0 || b >= n) {
            alert("Data block " + b + " vượt kích thước đĩa!");
            return;
        }
    }

    const highlight = [idx, ...dataBlocks];

    let text = "== Indexed Allocation (i-node) ==\n";
    text += "Index block (i-node) = " + idx + "\n";
    text += "Danh sách block dữ liệu: " +
            (dataBlocks.length ? dataBlocks.join(", ") : "(trống)") + "\n\n";
    text += "Directory lưu số hiệu index block; index block chứa con trỏ tới các block dữ liệu.\n";

    animatePath(highlight, text);
    renderIndexedDiagram(n, idx, dataBlocks);
    animateIndexedDiagram(idx, dataBlocks);
}

/* ---------------------- TAB 4: ACCESS METHODS ---------------------- */
let accessAnimTimer = null;

function clearAccessAnimation() {
    if (accessAnimTimer) {
        clearInterval(accessAnimTimer);
        accessAnimTimer = null;
    }
}

function logAccess(msg) {
    const out = document.getElementById("accessOutput");
    out.innerHTML += msg + "\n";
    out.scrollTop = out.scrollHeight;
}

function getAccessRecords() {
    const raw = document.getElementById("accessFile").value.trim();
    if (!raw) return [];
    return raw.split(",").map(x => x.trim()).filter(x => x.length > 0);
}

/* vẽ hàng record cơ bản */
function renderAccessBase(recs) {
    const container = document.getElementById("accessDiagram");
    if (!container) return;

    if (!recs || recs.length === 0) {
        container.innerHTML = "<i>File đang trống. Hãy nhập các bản ghi (vd: R1,R2,R3,...).</i>";
        return;
    }

    let html = `
      <div class="access-layout">
        <div class="file-box">
          <div class="file-title">File (Chuỗi bản ghi)</div>
          <div class="records-row">
    `;

    recs.forEach((r, i) => {
        html += `
          <div class="record-block" id="rec_${i}">
            <div class="idx">[${i}]</div>
            <div class="val">${r}</div>
          </div>
        `;
    });

    html += `
          </div>
        </div>
        <div class="access-extra" id="accessExtra">
          <div class="access-extra-title">Bảng minh họa</div>
          <p style="font-size:12px;">Chạy một demo để xem cấu trúc tương ứng.</p>
        </div>
      </div>
    `;

    container.innerHTML = html;
}

/* 4.1 Sequential */
function demoSequential() {
    const recs = getAccessRecords();
    if (recs.length === 0) {
        alert("Nhập ít nhất 1 bản ghi trong file!");
        return;
    }
    document.getElementById("accessOutput").innerHTML = "";
    clearAccessAnimation();
    renderAccessBase(recs);

    logAccess("== Sequential Access ==");
    logAccess("Đọc lần lượt từng bản ghi từ đầu tới cuối.\n");

    let step = -1;

    accessAnimTimer = setInterval(() => {
        step++;

        recs.forEach((_, i) => {
            const el = document.getElementById("rec_" + i);
            if (el) el.classList.remove("active");
        });

        if (step >= recs.length) {
            clearAccessAnimation();
            logAccess("Kết thúc: đã duyệt hết " + recs.length + " bản ghi.");
            return;
        }

        const el = document.getElementById("rec_" + step);
        if (el) el.classList.add("active");
        logAccess("Bước " + (step + 1) + ": đọc record[" + step + "] = " + recs[step]);
    }, 700);
}

/* 4.2 Direct */
function demoDirect() {
    const recs = getAccessRecords();
    const pos = parseInt(document.getElementById("accessPos").value);
    if (recs.length === 0) {
        alert("Nhập ít nhất 1 bản ghi trong file!");
        return;
    }
    if (isNaN(pos) || pos < 0 || pos >= recs.length) {
        alert("Vị trí không hợp lệ!");
        return;
    }
    document.getElementById("accessOutput").innerHTML = "";
    clearAccessAnimation();
    renderAccessBase(recs);

    recs.forEach((_, i) => {
        const el = document.getElementById("rec_" + i);
        if (el) el.classList.remove("active");
    });
    const target = document.getElementById("rec_" + pos);
    if (target) target.classList.add("active");

    logAccess("== Direct Access ==");
    logAccess("Số record trong file: " + recs.length);
    logAccess("Nhảy thẳng đến record[" + pos + "] và đọc = " + recs[pos]);
    logAccess("Không cần đọc tuần tự các bản ghi phía trước.");
}

/* 4.3 Indexed Access */
function demoIndexedAccess() {
    const recs = getAccessRecords();
    const key = document.getElementById("accessKeyIndex").value.trim();
    if (recs.length === 0) {
        alert("Nhập ít nhất 1 bản ghi trong file!");
        return;
    }
    if (!key) {
        alert("Nhập khóa bản ghi (vd: R3)");
        return;
    }

    document.getElementById("accessOutput").innerHTML = "";
    clearAccessAnimation();
    renderAccessBase(recs);

    const indexTable = {};
    recs.forEach((r, i) => { indexTable[r] = i; });

    const extra = document.getElementById("accessExtra");
    let html = `
      <div class="access-extra-title">Bảng chỉ mục (record → vị trí)</div>
      <table class="access-table">
        <tr><th>Khóa</th><th>Vị trí</th></tr>
    `;
    recs.forEach((r, i) => {
        html += `<tr id="idxRow_${i}"><td>${r}</td><td>${i}</td></tr>`;
    });
    html += `</table>`;
    extra.innerHTML = html;

    logAccess("== Indexed Access ==");
    logAccess("Tạo bảng chỉ mục: record → vị trí.\n");

    const pos = indexTable[key];

    if (pos === undefined) {
        logAccess("Khóa '" + key + "' không tồn tại trong bảng chỉ mục.");
        return;
    }

    logAccess("Tra cứu khóa '" + key + "':");
    logAccess("Bước 1: tìm trong bảng chỉ mục → vị trí = " + pos);
    logAccess("Bước 2: nhảy tới record[" + pos + "] = " + recs[pos]);

    // highlight: trước dòng index, sau đó record
    const row = document.getElementById("idxRow_" + pos);
    const recEl = document.getElementById("rec_" + pos);

    if (row) {
        row.classList.add("active");
        setTimeout(() => {
            if (recEl) recEl.classList.add("active");
        }, 600);
    } else if (recEl) {
        recEl.classList.add("active");
    }
}

/* 4.4 Hashed Access */
function demoHashedAccess() {
    const recs = getAccessRecords();
    const key = document.getElementById("accessKeyHash").value.trim();
    if (!key) {
        alert("Nhập khóa cần băm (vd: user42)");
        return;
    }

    const BUCKETS = 5;
    function hash(str) {
        let sum = 0;
        for (let i = 0; i < str.length; i++) sum += str.charCodeAt(i);
        return sum % BUCKETS;
    }

    const keys = recs.length ? recs.slice(0) : ["A","B","C","D","E"];
    const table = {};
    keys.forEach(k => {
        const h = hash(k);
        if (!table[h]) table[h] = [];
        table[h].push(k);
    });

    document.getElementById("accessOutput").innerHTML = "";
    clearAccessAnimation();
    renderAccessBase(recs);

    const extra = document.getElementById("accessExtra");
    let html = `
      <div class="access-extra-title">Bảng băm (Hash table)</div>
      <table class="access-table">
        <tr><th>Bucket</th><th>Các khóa</th></tr>
    `;
    for (let b = 0; b < BUCKETS; b++) {
        const list = table[b] ? table[b].join(", ") : "(trống)";
        html += `<tr id="bucketRow_${b}"><td>${b}</td><td>${list}</td></tr>`;
    }
    html += `</table>`;
    extra.innerHTML = html;

    const hk = hash(key);

    logAccess("== Hashed Access ==");
    logAccess("Số bucket: " + BUCKETS);
    logAccess("hash('" + key + "') = " + hk + " → tra cứu trong Bucket " + hk);

    const row = document.getElementById("bucketRow_" + hk);
    if (row) row.classList.add("active");
}

/* init */
initDisk();
</script>
</body>
</html>
